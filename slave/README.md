## little-meter 下位机程序

下位机程序适用于ESP8266/ESP32 for Arduino开发环境。

### 简明教程

1. 安装Arduino软件
2. 安装[ESP8266](https://github.com/esp8266/Arduino#readme)或者[ESP32](https://github.com/espressif/arduino-esp32#readme)的Arduino Package
3. 选择你的实际开发板型号和串行端口号
4. 搜索安装以下Arduino Libraries

| 库名称                                                  | 版本    | 作者            |
| ------------------------------------------------------- | ------- | --------------- |
| [ArduinoJson](https://github.com/bblanchon/ArduinoJson) | 6.19.4  | Benoit Blanchon |
| [U8G2](https://github.com/olikraus/u8g2)                | 2.23.15 | oliver          |

3. 点击**上传**按钮将程序烧写到开发板上
4. 打开串口监视器，在输入栏输入`{"ssid":"your-ssid","password":"your-password"}`，将`your-ssid`和`your-password`替换为你的WiFi名字和密码并点击发送按钮来设置wifi参数
5. wifi参数设置好后芯片会重启，并会连接到刚指定的WIFI上
6. 通过屏幕上的IP地址和端口号，将上位机程序连接上来就可以使用了

### 屏幕文字说明

屏幕上会显示芯片当前的各种状态，以供调试和诊断之用途。

| 显示文本                        | 描述                                    | 附加                                             |
| ------------------------------- | --------------------------------------- | ------------------------------------------------ |
| 192.168.1.100:9080 \| RSSI: -50 | WIFI连接成功，并显示了对应的API地址端口 | RSSI为信号强度，越大越好（比如-40大于-50）       |
| ssid not specified              | 还未通过串口设置WIFI名称密码等参数      | 第一次使用需要先设置一下WIFI名称和密码           |
| searching for signal            | 正在连接到指定的WIFI上                  | 如果WIFI未启用DHCP会一直卡在这一步               |
| no ssid signal available        | 找不到指定的WIFI信号                    | 可能距离WIFI太远信号太弱或者配置时WIFI名字打错了 |
| wifi disconnected               | 无法连接到指定的WIFI上                  | 通常是配置时WIFI密码输入错误或者被踢出WIFI网络   |

### API通信协议

WIFI连接成功后会在屏幕上显示当前设备的IP和端口号。只需要使用TCP连接到这个端口号上面，然后使用特定的数据格式进行通信，就可以控制屏幕上显示的内容了。

API的协议主要为单向通讯，也就是数据主要是从上位机发往下位机的，至于下位机发回的信息，可以忽略掉不做任何处理。

通信协议使用基于二进制协议的**数据帧**来通信，为了传输效率，并没有使用基于文本的协议。

每一个数据帧都由一个单字节的**指令码**开头，**指令码**后面紧接着的是对应的**载荷数据**。（可以将**指令码**理解为函数名，**载荷数据**理解为函数参数）

目前支持3个指令码：（指令码都为ascii字符）

1. `b`（buffer）：后面紧跟512/1024个字节，用来更新画面缓冲区内容
2. `c`（contrast）：后面紧跟1个字节（0-255个档位），用来设置显示器亮度（此值会被持久化）
3. `r`（restart）：不需要跟任何字节，此指令用来重启芯片

#### ScreenBuffer更新协议

当上位机连接到下位机的API上后，所有的图形绘制工作都是在上位机完成的。上位机会将绘制好的图形缓冲区内容发送给下位机进行显示。

指令码b后面要跟上的实际字节数，需要根据屏幕分辨率大小进行计算，如果是12864的屏幕：`128 * 64 / 8 = 1024`个字节。如果是12832的屏幕：`128 * 32 / 8 = 512`个字节

这些字节的排列顺序如下，先从左到右，然后从上到下。字节和字节间的顺序使用高位先行大端模式，同一字节内的比特位也使用高位先行的大端模式

```
byte0[0] byte0[1] byte0[2] byte0[3] byte0[4] byte0[5] byte0[6] byte0[7] byte1[0] byte1[1] byte1[2] .....
......
byte6[0] byte6[1] byte6[2] byte6[3] ....
.............................................................................
```

